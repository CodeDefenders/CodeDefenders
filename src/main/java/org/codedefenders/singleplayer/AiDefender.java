package org.codedefenders.singleplayer;

import org.codedefenders.*;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.crypto.Data;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import static org.codedefenders.Constants.*;

/**
 * @author Ben Clegg
 * An AI defender. Uses tests generated by EvoSuite to kill mutants.
 */
public class AiDefender extends AiPlayer {

	public AiDefender(Game g) {
		super(g);
		role = Game.Role.DEFENDER;
	}
	public boolean turnHard() {
		//Choose test which kills a high number of generated mutants.
		return runTurn(GenerationMethod.KILLCOUNT);
	}

	public boolean turnEasy() {
		//Choose random test.
		return runTurn(GenerationMethod.RANDOM);
	}

	protected boolean runTurn(GenerationMethod strat) {
		try {
			TestsIndexContents ind = new TestsIndexContents(game.getCUT());

			int tNum = selectTest(strat, ind);
			try {
				useTestFromSuite(tNum, ind);
			} catch (IOException e) {
				e.printStackTrace();
				return false;
			}
		} catch (Exception e) {
			//Assume no more choices remain.
			//Do nothing.
		}

		return true;
	}

	private int selectTest(GenerationMethod strategy, TestsIndexContents indexCon) throws Exception {

		ArrayList<Integer> usedTests = DatabaseAccess.getUsedAiTestsForGame(game);
		int totalTests = indexCon.getNumTests();
		Exception e = new Exception("No choices remain.");

		if(usedTests.size() == totalTests) {
			throw e;
		}
		int t = -1;

		//Get available tests, only ones in the xml file
		//Prevents usage of useless tests
		ArrayList<Test> origTests = new ArrayList<Test>();
		for (int tId : indexCon.getTestIds()) {
			origTests.add(DatabaseAccess.getTestForId(tId));
		}

		for (int i = 0; i <= 3; i++) {
			//Try to get test by default strategy.
			int n = -1;
			if (strategy.equals(GenerationMethod.RANDOM)) {
				n = (int) Math.floor(Math.random() * totalTests);
				//0 -> totalTests - 1.
			}
			else if (strategy.equals(GenerationMethod.KILLCOUNT)) {
				//Sort tests in order of killcount.
				Collections.sort(origTests, new TestComparator());

				//Get an index, using a random number biased towards later index.
				//More extreme than attacker due to smaller sample size.
				n = PrepareAI.biasedSelection(origTests.size(), 0.6);
			}
			//TODO: Other strategies.

			//Check that an id has been retrieved.
			if(n >= 0) {
				//Get original test from dummy game's list of tests.
				Test origT = origTests.get(n);
				t = origT.getId();

				if ((!usedTests.contains(t)) && (t != -1)) {
					//Strategy found an unused test.
					return t;
				}
			}

		}

		//If standard strategy fails, choose first non-selected test.
		for (int x = 0; x < totalTests; x++) {

			Test origT = origTests.get(x);
			t = origT.getId();

			if(!usedTests.contains(t)) {
				//Unused test found.
				return t;
			}
		}

		//Something went wrong.
		throw e;
	}

	private void useTestFromSuite(int origTestNum, TestsIndexContents indexCon) throws IOException {
		Game dummyGame = DatabaseAccess.getGameForKey("Game_ID", indexCon.getDummyGameId());
		ArrayList<Test> origTests = dummyGame.getTests();

		Test origT = null;

		for (Test t : origTests) {
			if(t.getId() == origTestNum) {
				origT = t;
				break;
			}
		}

		if(origT != null) {
			String jFile = origT.getJavaFile();
			String cFile = origT.getClassFile();
			Test t = new Test(game.getId(), jFile, cFile, 1);
			t.insert();
			t.update();
			TargetExecution newExec = new TargetExecution(t.getId(), 0, TargetExecution.Target.COMPILE_TEST, "SUCCESS", null);
			newExec.insert();
			ArrayList<String> messages = new ArrayList<String>();
			MutationTester.runTestOnAllMutants(game, t, messages);
			DatabaseAccess.setAiTestAsUsed(origTestNum, game);
			File dir = new File(origT.getFolder());
			AntRunner.testOriginal(dir, t);
			game.update();
		}
	}

}

class TestsIndexContents {

	private ArrayList<Integer> testIds;
	private int dummyGameId;
	private int numTests;

	public TestsIndexContents(GameClass cut) {
		testIds = new ArrayList<Integer>();
		dummyGameId = -1;
		numTests = -1;
		//Parse the test index file of a given class.
		try {
			File f = new File(AI_DIR + F_SEP + "tests" + F_SEP +
					cut.getAlias() + F_SEP + "TestsIndex" + TEST_INFO_EXT);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuild = dbFactory.newDocumentBuilder();
			Document d = dBuild.parse(f);

			d.getDocumentElement().normalize();

			NodeList tNodes = d.getElementsByTagName("test");
			for (int i = 0; i < tNodes.getLength(); i++) {
				Node tNode = tNodes.item(i);
				Node id = tNode.getAttributes().getNamedItem("id");
				testIds.add(Integer.parseInt(id.getTextContent()));
			}
			NodeList q = d.getElementsByTagName("quantity");
			numTests = Integer.parseInt(q.item(0).getTextContent());
			NodeList g = d.getElementsByTagName("dummygame");
			dummyGameId = Integer.parseInt(g.item(0).getTextContent());

		} catch (Exception e) {
			e.printStackTrace();
			//TODO: Handle errors.
		}


	}

	public ArrayList<Integer> getTestIds() {
		return testIds;
	}

	public int getNumTests() {
		return numTests;
	}

	public int getDummyGameId() {
		return dummyGameId;
	}

}

class TestComparator implements Comparator<Test> {
	@Override
	public int compare(Test t1, Test t2) {
		return t1.getAiMutantsKilled() - t2.getAiMutantsKilled();
	}
}