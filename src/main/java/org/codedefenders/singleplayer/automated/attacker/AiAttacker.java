package org.codedefenders.singleplayer.automated.attacker;

import org.codedefenders.*;
import org.codedefenders.singleplayer.AiPlayer;
import org.codedefenders.singleplayer.PrepareAI;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;

/**
 * @author Ben Clegg
 * An AI attacker, which chooses mutants generated by Major when the class is uploaded.
 */
public class AiAttacker extends AiPlayer {

	private static final Logger logger = LoggerFactory.getLogger(AiAttacker.class);

	public static final int ID = 1;

	public AiAttacker(Game g) {
		super(g);
		role = Role.ATTACKER;
	}

	/**
	 * Hard difficulty attacker turn.
	 * @return true if mutant generation succeeds, or if no non-existing mutants have been found to prevent infinite loop.
	 */
	public boolean turnHard() {
		//Choose a mutant which is killed by few generated tests.
		return runTurn(GenerationMethod.KILLCOUNT);
	}

	/**
	 * Easy difficulty attacker turn.
	 * @return true if mutant generation succeeds, or if no non-existing mutants have been found to prevent infinite loop.
	 */
	public boolean turnEasy() {
		//Choose a random mutant.
		return runTurn(GenerationMethod.RANDOM);
	}

	protected boolean runTurn(GenerationMethod strat) {
		try {
			int mNum = selectMutant(strat);
			useMutantFromSuite(mNum);
		} catch (IOException e) {
			e.printStackTrace();
			return false;
		} catch (Exception e) {
			//Assume no more unused mutants remain, do nothing.
			logger.info("something went wrong; skipping turn");
		}

		return true;
	}

	private int selectMutant(GenerationMethod strategy) throws Exception {
		ArrayList<Integer> usedMutants = DatabaseAccess.getUsedAiMutantsForGame(game);
		GameClass cut = game.getCUT();
		Game dummyGame = cut.getDummyGame();
		ArrayList<Mutant> origMutants = dummyGame.getMutants();

		int totalMutants = origMutants.size();

		Exception e = new Exception("No unused mutants remain.");
		if(usedMutants.size() == totalMutants) {
			throw e;
		}
		int m = -1;

		for (int i = 0; i < 10; i++) {
			//Try standard strategy to select a mutant.
			int n = -1;
			if(strategy.equals(GenerationMethod.RANDOM)) {
				n = (int) Math.floor(Math.random() * totalMutants);
				//0 -> totalMutants - 1.
			}
			else if(strategy.equals(GenerationMethod.KILLCOUNT)) {
				//Sort tests in order of killcount.
				Collections.sort(origMutants, new MutantComparator());

				//Get an index, using a random number biased towards earlier index.
				//Note mutants with low killcount are more likely to be equivalent.
				n = PrepareAI.biasedSelection(origMutants.size(), 1.7);
			}

			if(n >= 0) {
				Mutant origM = origMutants.get(n);
				m = origM.getId();

				if ((!usedMutants.contains(m)) && (m != -1)) {
					//Found an unused mutant.
					return m;
				}
			}

		}

		//If standard strategy fails, make a choice linearly.
		for (int x = 0; x < totalMutants; x++) {

			Mutant origM = origMutants.get(x);
			m = origM.getId();

			if(!usedMutants.contains(m)) {
				//Found an unused mutant.
				return m;
			}
		}

		//Something went wrong.
		throw e;
	}

	private void useMutantFromSuite(int origMutNum) throws IOException, Exception {
		GameClass cut = game.getCUT();
		Game dummyGame = cut.getDummyGame();
		ArrayList<Mutant> origMutants = dummyGame.getMutants();

		Mutant origM = null;

		for (Mutant m : origMutants) {
			if(m.getId() == origMutNum) {
				origM = m;
				break;
			}
		}

		if(origM != null) {
			String jFile = origM.getSourceFile();
			String cFile = origM.getClassFile();
			int playerId = DatabaseAccess.getPlayerIdForMultiplayerGame(ID, game.getId());
			Mutant m = new Mutant(game.getId(), jFile, cFile, true, playerId);
			m.insert();
			m.update();

			MutationTester.runAllTestsOnMutant(game, m, messages);
			DatabaseAccess.setAiMutantAsUsed(origMutNum, game);
			game.update();
		}
	}

	@Override
	public ArrayList<String> getMessagesLastTurn() {
		boolean killed = false;
		for (String s : messages) {
			if (s.contains("killed your mutant")) {
				killed = true;
				break;
			}
		}
		messages.clear();
		if (killed)
			messages.add("The AI submitted a new mutant, but one of your tests killed it inmediately!");
		else
			messages.add("The AI submitted a new mutant.");
		return messages;
	}
}