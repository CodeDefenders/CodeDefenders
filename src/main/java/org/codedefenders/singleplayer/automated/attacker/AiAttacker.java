package org.codedefenders.singleplayer.automated.attacker;

import org.codedefenders.*;
import org.codedefenders.singleplayer.AiPlayer;
import org.codedefenders.singleplayer.PrepareAI;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.io.File;

import static org.codedefenders.Constants.*;

/**
 * @author Ben Clegg
 * An AI attacker, which chooses mutants generated by Major when the class is uploaded.
 */
public class AiAttacker extends AiPlayer {

	public static final int ID = 1;

	public AiAttacker(Game g) {
		super(g);
		role = Role.ATTACKER;
	}

	/**
	 * Hard difficulty attacker turn.
	 * @return true if mutant generation succeeds, or if no non-existing mutants have been found to prevent infinite loop.
	 */
	public boolean turnHard() {
		//Choose a mutant which is killed by few generated tests.
		return runTurn(GenerationMethod.KILLCOUNT);
	}

	/**
	 * Easy difficulty attacker turn.
	 * @return true if mutant generation succeeds, or if no non-existing mutants have been found to prevent infinite loop.
	 */
	public boolean turnEasy() {
		//Choose a random mutant.
		return runTurn(GenerationMethod.RANDOM);
	}

	protected boolean runTurn(GenerationMethod strat) {
		try {
			MutantsIndexContents ind = new MutantsIndexContents(game.getCUT());

			int mNum = selectMutant(strat, ind);
			try {
				useMutantFromSuite(mNum, ind);
			} catch (IOException e) {
				e.printStackTrace();
				return false;
			}
		} catch (Exception e) {
			//Assume no more unused mutants remain, do nothing.
		}

		return true;
	}


	private int selectMutant(GenerationMethod strategy, MutantsIndexContents indexCon) throws Exception {
		ArrayList<Integer> usedMutants = DatabaseAccess.getUsedAiMutantsForGame(game);
		Exception e = new Exception("No unused mutants remain.");
		int totalMutants = indexCon.getNumMutants();

		if(usedMutants.size() == totalMutants) {
			throw e;
		}
		int m = -1;

		Game dummyGame = DatabaseAccess.getGameForKey("ID", indexCon.getDummyGameId());
		ArrayList<Mutant> origMutants = dummyGame.getMutants();

		for (int i = 0; i < 10; i++) {
			//Try standard strategy to select a mutant.
			int n = -1;
			if(strategy.equals(GenerationMethod.RANDOM)) {
				n = (int) Math.floor(Math.random() * totalMutants);
				//0 -> totalMutants - 1.
			}
			else if(strategy.equals(GenerationMethod.KILLCOUNT)) {
				//Sort tests in order of killcount.
				Collections.sort(origMutants, new MutantComparator());

				//Get an index, using a random number biased towards earlier index.
				//Note mutants with low killcount are more likely to be equivalent.
				n = PrepareAI.biasedSelection(origMutants.size(), 1.7);
			}

			if(n >= 0) {
				Mutant origM = origMutants.get(n);
				m = origM.getId();

				if ((!usedMutants.contains(m)) && (m != -1)) {
					//Found an unused mutant.
					return m;
				}
			}

		}

		//If standard strategy fails, make a choice linearly.
		for (int x = 0; x < totalMutants; x++) {

			Mutant origM = origMutants.get(x);
			m = origM.getId();

			if(!usedMutants.contains(m)) {
				//Found an unused mutant.
				return m;
			}
		}

		//Something went wrong.
		throw e;
	}

	private void useMutantFromSuite(int origMutNum, MutantsIndexContents indexCon) throws IOException {
		Game dummyGame = DatabaseAccess.getGameForKey("ID", indexCon.getDummyGameId());
		ArrayList<Mutant> origMutants = dummyGame.getMutants();

		Mutant origM = null;

		for (Mutant m : origMutants) {
			if(m.getId() == origMutNum) {
				origM = m;
				break;
			}
		}

		if(origM != null) {
			String jFile = origM.getSourceFile();
			String cFile = origM.getClassFile();
			int playerId = DatabaseAccess.getPlayerIdForMultiplayerGame(ID, game.getId());
			Mutant m = new Mutant(game.getId(), jFile, cFile, true, playerId);
			m.insert();
			m.update();

			ArrayList<String> messages = new ArrayList<String>();
			MutationTester.runAllTestsOnMutant(game, m, messages);
			DatabaseAccess.setAiMutantAsUsed(origMutNum, game);
			game.update();
		}
	}

}