package org.codedefenders.singleplayer.automated.defender;

import org.codedefenders.*;
import org.codedefenders.multiplayer.LineCoverage;
import org.codedefenders.singleplayer.AiPlayer;
import org.codedefenders.singleplayer.PrepareAI;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

/**
 * @author Ben Clegg
 * An AI defender. Uses tests generated by EvoSuite to kill mutants.
 */
public class AiDefender extends AiPlayer {

	private static final Logger logger = LoggerFactory.getLogger(AiDefender.class);

	public static final int ID = 2;

	public AiDefender(Game g) {
		super(g);
		role = Role.DEFENDER;
	}
	public boolean turnHard() {
		//Choose test which kills a high number of generated mutants.
		return runTurn(GenerationMethod.COVERAGE);
		//return runTurn(GenerationMethod.KILLCOUNT);
	}

	public boolean turnEasy() {
		//Choose random test.
		return runTurn(GenerationMethod.RANDOM);
	}

	protected boolean runTurn(GenerationMethod strat) {
		try {
			TestsIndexContents ind = new TestsIndexContents(game.getCUT());

			int tNum = selectTest(strat);
			try {
				useTestFromSuite(tNum, ind);
			} catch (IOException e) {
				e.printStackTrace();
				return false;
			}
		} catch (Exception e) {
			e.printStackTrace();
			//Assume no more choices remain.
			//Do nothing.
		}

		return true;
	}

	private int selectTest(GenerationMethod strategy) throws Exception {

		ArrayList<Integer> usedTests = DatabaseAccess.getUsedAiTestsForGame(game);
		GameClass cut = game.getCUT();
		Game dummyGame = cut.getDummyGame();

		//Get all available tests from dummy game
		ArrayList<Test> origTests = new ArrayList<Test>();
		for (Test t : dummyGame.getTests()) {
			origTests.add(t);
		}

		int totalTests = origTests.size();

		//Throw an exception if all tests used
		Exception e = new Exception("No choices remain.");
		if(usedTests.size() == totalTests) {
			throw e;
		}
		int t = -1;


		//Discard useless tests in origtests (ie tests with killcount of zero
		for (Test tA : origTests) {
			if(tA.getAiMutantsKilled() == 0) {
				origTests.remove(origTests.indexOf(tA));
			}
		}

		Test covTest = null;
		int bestCoverage = 0;
		if (strategy.equals(GenerationMethod.COVERAGE)) {
			//Choose a test which covers the most lines of alive mutants.
			//Get all alive mutated line numbers.

			ArrayList<Mutant> muts = game.getAliveMutants();
			HashSet<Integer> linesModified = new HashSet<Integer>();
			for (Mutant m : muts) {
				linesModified.addAll(m.getLines());
			}
			logger.debug("Alive mutated lines: {}", linesModified.toString());

			for (Test tst : origTests) {
				//Test must not be used yet.
				if(!usedTests.contains(tst)) {
					LineCoverage lc = tst.getLineCoverage(); // test already has line coverage information here
					ArrayList<Integer> coveredByTest = lc.getLinesCovered();
					int coverage = 0;
					System.out.print("Test covers lines: ");
					for (int l : coveredByTest) {
						System.out.print(l);
						if(linesModified.contains(l)) {
							System.out.print("[HIT]");
							//Test covers this mutated line.
							coverage ++;
						}
						System.out.print(", ");
					}
					System.out.println();
					if (coverage > bestCoverage) {
						//Test is the best unused test found.
						covTest = tst;
						bestCoverage = coverage;
					}
				}
			}
			if (covTest != null) {
				//Just use the found test if using line coverage method.
				return covTest.getId();
			} else {
				System.out.println("No test covers an alive mutated line, using killcount instead.");
				strategy = GenerationMethod.KILLCOUNT;
			}
		}
		//If not line coverage, or no lines are covered.
		if (bestCoverage == 0) {
			//Repeat multiple times for non-deterministic strategies.
			for (int i = 0; i <= 3; i++) {
				//Try to get test by default strategy.
				int n = -1;

				if (strategy.equals(GenerationMethod.RANDOM)) {
					n = (int) Math.floor(Math.random() * totalTests);
					//0 -> totalTests - 1.
				}
				else if (strategy.equals(GenerationMethod.KILLCOUNT)) {
					//Sort tests in order of killcount.
					Collections.sort(origTests, new TestComparator());

					//Get an index, using a random number biased towards later index.
					//More extreme than attacker due to smaller sample size.
					n = PrepareAI.biasedSelection(origTests.size(), 0.6);
				}

				//Check that an id has been retrieved.
				if(n >= 0) {
					//Get original test from dummy game's list of tests.
					Test origT = origTests.get(n);
					t = origT.getId();

					if ((!usedTests.contains(t)) && (t != -1)) {
						//Strategy found an unused test.
						return t;
					}
				}

			}
		}



		//If standard strategy fails, choose first non-selected test.
		for (int x = 0; x < totalTests; x++) {

			Test origT = origTests.get(x);
			t = origT.getId();

			if(!usedTests.contains(t)) {
				//Unused test found.
				return t;
			}
		}

		//Something went wrong.
		throw e;
	}

	private void useTestFromSuite(int origTestNum, TestsIndexContents indexCon) throws IOException {
		Game dummyGame = DatabaseAccess.getGameForKey("ID", indexCon.getDummyGameId());
		ArrayList<Test> origTests = dummyGame.getTests();

		Test origT = null;

		for (Test t : origTests) {
			if(t.getId() == origTestNum) {
				origT = t;
				break;
			}
		}

		if(origT != null) {
			String jFile = origT.getJavaFile();
			String cFile = origT.getClassFile();
			int playerId = DatabaseAccess.getPlayerIdForMultiplayerGame(ID, game.getId());
			Test t = new Test(game.getId(), jFile, cFile, playerId);
			t.insert();
			t.update();
			TargetExecution newExec = new TargetExecution(t.getId(), 0, TargetExecution.Target.COMPILE_TEST, "SUCCESS", null);
			newExec.insert();
			MutationTester.runTestOnAllMutants(game, t, messages);
			DatabaseAccess.setAiTestAsUsed(origTestNum, game);
			File dir = new File(origT.getFolder());
			AntRunner.testOriginal(dir, t);
			game.update();
		}
	}

	@Override
	public ArrayList<String> getMessagesLastTurn() {
		boolean killed = false;
		for (String s : messages) {
			if (s.contains("test killed")) {
				killed = true;
				break;
			}
		}
		messages.clear();
		if (killed)
			messages.add("The AI submitted a new test, which killed at least one mutant.");
		else
			messages.add("The AI submitted a new test, which did not kill any mutant.");
		return messages;
	}
}

